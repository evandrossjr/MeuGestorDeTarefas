# Arquivo: azure-pipelines.yml

# 1. GATILHO (TRIGGER)
# Esta seção define quando o pipeline deve ser executado automaticamente.
# Aqui, ele será acionado a cada novo commit ou merge na branch 'main'.
trigger:
  - main

# 2. AMBIENTE DE EXECUÇÃO (POOL)
# Define o tipo de máquina virtual que o Azure vai usar para rodar nosso pipeline.
# 'ubuntu-latest' é uma máquina Linux moderna, perfeita para builds Java/Docker.
pool:
  vmImage: 'ubuntu-latest'

# 3. ETAPAS DO PIPELINE (STAGES)
# Um pipeline é dividido em estágios. Para um CI simples, teremos um único estágio de "Build".
stages:
  - stage: Build
    displayName: 'Build and Test Stage'
    jobs:
      - job: Build
        displayName: 'Build, test, and publish artifacts'
        steps:

          # PASSO 1: Configurar a versão correta do Java (JDK)
          # Garante que a máquina virtual use a mesma versão Java do nosso projeto.
          - task: JavaToolInstaller@0
            inputs:
              versionSpec: '21' # A versão do nosso projeto
              jdkArchitectureOption: 'x64'
              jdkSourceOption: 'Temurin' # Usando a distribuição Temurin (antiga AdoptOpenJDK)

          # PASSO 2: Executar o Build com Maven
          # Este é o passo principal. Ele compila o código, RODA OS TESTES e empacota a aplicação.
          - task: Maven@4
            displayName: 'Build with Maven'
            inputs:
              mavenPomFile: 'pom.xml'
              goals: 'clean package' # Executa os comandos 'mvn clean package'
              options: '-Djava.awt.headless=true'
              publishJUnitTestResults: true # Publica os resultados dos testes para visualização no Azure DevOps
              testResultsFiles: '**/surefire-reports/TEST-*.xml'
              javaHomeOption: 'JDKVersion'
              jdkVersionOption: '1.21' # Garante que o Maven use o JDK que instalamos acima
              mavenVersionOption: 'Default'
              mavenAuthenticateFeed: false
              effectivePomSkip: false
              sonarQubeRunAnalysis: false
              # Habilita o cache de dependências do Maven para builds futuros serem mais rápidos
              cache: 'maven'

          # PASSO 3: Copiar os Arquivos para o Artefato
          # Preparamos os arquivos que serão "publicados" (salvos) pelo pipeline.
          - task: CopyFiles@2
            displayName: 'Copy Files to Artifact Staging Directory'
            inputs:
              SourceFolder: '$(Build.SourcesDirectory)'
              Contents: |
                target/*.jar
                Dockerfile
                docker-compose.yml
              TargetFolder: '$(Build.ArtifactStagingDirectory)'

          # PASSO 4: Publicar os Artefatos do Build
          # Salva o resultado do nosso build para que a próxima fase (o Deploy Contínuo) possa usá-lo.
          - task: PublishBuildArtifacts@1
            displayName: 'Publish Artifact: drop'
            inputs:
              PathtoPublish: '$(Build.ArtifactStagingDirectory)'
              ArtifactName: 'drop' # O nome do nosso "pacote" de artefatos
              publishLocation: 'Container'